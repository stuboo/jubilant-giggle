var d=`
local key = KEYS[1]
local field = ARGV[1]

local data = redis.call("ZRANGE", key, 0, -1, "WITHSCORES")
local count = {}

for i = 1, #data, 2 do
  local json_str = data[i]
  local score = tonumber(data[i + 1])
  local obj = cjson.decode(json_str)

  local fieldValue = obj[field]

  if count[fieldValue] == nil then
    count[fieldValue] = score
  else
    count[fieldValue] = count[fieldValue] + score
  end
end

local result = {}
for k, v in pairs(count) do
  table.insert(result, {k, v})
end

return result
`,g=`
local prefix = KEYS[1]
local first_timestamp = tonumber(ARGV[1])
local increment = tonumber(ARGV[2])
local num_timestamps = tonumber(ARGV[3])
local num_elements = tonumber(ARGV[4])

local keys = {}
for i = 1, num_timestamps do
  local timestamp = first_timestamp - (i - 1) * increment
  table.insert(keys, prefix .. ":" .. timestamp)
end

-- get the union of the groups
local zunion_params = {"ZUNION", num_timestamps, unpack(keys)}
table.insert(zunion_params, "WITHSCORES")
local result = redis.call(unpack(zunion_params))

-- select num_elements many items
local true_group = {}
local false_group = {}
local denied_group = {}
local true_count = 0
local false_count = 0
local denied_count = 0
local i = #result - 1

-- iterate over the results
while (true_count + false_count + denied_count) < (num_elements * 3) and 1 <= i do
  local score = tonumber(result[i + 1])
  if score > 0 then
    local element = result[i]
    if string.find(element, "success\\":true") and true_count < num_elements then
      table.insert(true_group, {score, element})
      true_count = true_count + 1
    elseif string.find(element, "success\\":false") and false_count < num_elements then
      table.insert(false_group, {score, element})
      false_count = false_count + 1
    elseif string.find(element, "success\\":\\"denied") and denied_count < num_elements then
      table.insert(denied_group, {score, element})
      denied_count = denied_count + 1
    end
  end
  i = i - 2
end

return {true_group, false_group, denied_group}
`,p=`
local prefix = KEYS[1]
local first_timestamp = tonumber(ARGV[1])
local increment = tonumber(ARGV[2])
local num_timestamps = tonumber(ARGV[3])

local keys = {}
for i = 1, num_timestamps do
  local timestamp = first_timestamp - (i - 1) * increment
  table.insert(keys, prefix .. ":" .. timestamp)
end

-- get the union of the groups
local zunion_params = {"ZUNION", num_timestamps, unpack(keys)}
table.insert(zunion_params, "WITHSCORES")
local result = redis.call(unpack(zunion_params))

return result
`;var b=class{redis;prefix;bucketSize;constructor(e){this.redis=e.redis,this.prefix=e.prefix??"@upstash/analytics",this.bucketSize=this.parseWindow(e.window)}validateTableName(e){if(!/^[a-zA-Z0-9_-]+$/.test(e))throw new Error(`Invalid table name: ${e}. Table names can only contain letters, numbers, dashes and underscores.`)}parseWindow(e){if(typeof e=="number"){if(e<=0)throw new Error(`Invalid window: ${e}`);return e}let s=/^(\d+)([smhd])$/;if(!s.test(e))throw new Error(`Invalid window: ${e}`);let[,i,n]=e.match(s),t=parseInt(i);switch(n){case"s":return t*1e3;case"m":return t*1e3*60;case"h":return t*1e3*60*60;case"d":return t*1e3*60*60*24;default:throw new Error(`Invalid window unit: ${n}`)}}getBucket(e){let s=e??Date.now();return Math.floor(s/this.bucketSize)*this.bucketSize}async ingest(e,...s){this.validateTableName(e),await Promise.all(s.map(async i=>{let n=this.getBucket(i.time),t=[this.prefix,e,n].join(":");await this.redis.zincrby(t,1,JSON.stringify({...i,time:void 0}))}))}formatBucketAggregate(e,s,i){let n={};return e.forEach(([t,r])=>{s=="success"&&(t=t===1?"true":t===null?"false":t),n[s]=n[s]||{},n[s][(t??"null").toString()]=r}),{time:i,...n}}async aggregateBucket(e,s,i){this.validateTableName(e);let n=this.getBucket(i),t=[this.prefix,e,n].join(":"),r=await this.redis.eval(d,[t],[s]);return this.formatBucketAggregate(r,s,n)}async aggregateBuckets(e,s,i,n){this.validateTableName(e);let t=this.getBucket(n),r=[];for(let o=0;o<i;o+=1)r.push(this.aggregateBucket(e,s,t)),t=t-this.bucketSize;return Promise.all(r)}async aggregateBucketsWithPipeline(e,s,i,n,t){this.validateTableName(e),t=t??48;let r=this.getBucket(n),o=[],c=this.redis.pipeline(),a=[];for(let l=1;l<=i;l+=1){let m=[this.prefix,e,r].join(":");c.eval(d,[m],[s]),o.push(r),r=r-this.bucketSize,(l%t==0||l==i)&&(a.push(c.exec()),c=this.redis.pipeline())}return(await Promise.all(a)).flat().map((l,m)=>this.formatBucketAggregate(l,s,o[m]))}async getAllowedBlocked(e,s,i){this.validateTableName(e);let n=[this.prefix,e].join(":"),t=this.getBucket(i),r=await this.redis.eval(p,[n],[t,this.bucketSize,s]),o={};for(let c=0;c<r.length;c+=2){let a=r[c],u=a.identifier,l=+r[c+1];o[u]||(o[u]={success:0,blocked:0}),o[u][a.success?"success":"blocked"]=l}return o}async getMostAllowedBlocked(e,s,i,n){this.validateTableName(e);let t=[this.prefix,e].join(":"),r=this.getBucket(n),[o,c,a]=await this.redis.eval(g,[t],[r,this.bucketSize,s,i]);return{allowed:this.toDicts(o),ratelimited:this.toDicts(c),denied:this.toDicts(a)}}toDicts(e){let s=[];for(let i=0;i<e.length;i+=1){let n=+e[i][0],t=e[i][1];s.push({identifier:t.identifier,count:n})}return s}};export{b as Analytics};
